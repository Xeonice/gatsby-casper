---
layout: post
title: Leetcode 数组部分总结分析
date: 2019-08-11T07:11:42.968Z
author: Helve
tags:
  - JavaScript
  - LeetCode
image: /asset/2018-08-10.jpg
---
# 概览
最近正在刷 `leetcode`，希望针对其中不同种类的题目进行一下解法总结，因此书写了这篇文章供复习使用。
该部分总结为 `leetcode` 中数组的题目，选取了其中前 200 道题目左右进行总结，随后会根据难易程度进行相应排列
# easy

* \#1 [两数之和](https://leetcode-cn.com/problems/two-sum/)
* \#26 [删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)
* \#27 [移除元素]()
* \#35 搜索插入位置
* \#53 最大子序和
* \#66 加一
* \#88 合并两个有序数组
* \#118 杨辉三角
* \#119 杨辉三角II
* \#121 买卖股票的最佳时机
* \#122 买卖股票的最佳时机II
* \#167 两数之和 II - 输入有序数组
* \#169 求众数
* \#189 旋转数组
* \#217 存在重复元素
* \#661 图片平滑器
* \#665 非递减序列
* \#674 最长连续递增序列
* \#832 翻转图像

## 两数之和（Two Sum）

两数之和是一道极其经典且简单的题目，以下介绍三种方法

1. 暴力法

   最简单的解法，遍历每个元素 `x`，并查找是否存在一个与 `target-x` 相等的元素
   
   ``` javascript
        // 暴力 AC
        var twoSum = function (nums, target) {
            for (let i = 0; i < nums.length; i++) {
                for (let j = i + 1; j < nums.length; j++) {
                    if (nums[j] == target - nums[i]) {
                        return [i, j];
                    }
                }
            }
            throw Error("No two sum solution");
        }
   ```
   **复杂度分析**
    * 时间复杂度：O（N^2）
    * 空间复杂度：O（1）
   
2. 两遍哈希表

    实际上这个问题能够被继续精简，通过空间换时间的方式降低时间复杂度
    
    本问题中，我们需要将 `index` 和 `elemenet` 一一对应起来，根据 `sum - target1 = target2` 这个准则，利用 `target1` 去哈希表中寻找 `target2`。

   ``` javascript
        // 使用了两次迭代
        var twoSum = function (nums, target) {
            const map = new Map();
            // 第一次迭代中，将数组的每个值 set 到 map 中
            for (let i = 0; i < nums.length; i++) {
                map.set(nums[i], i);
            }
            // 第二次迭代中，寻找 hashmap 中是否存在 target - nums[i]
            for (let i = 0; i < nums.length; i++) {
                let complement = target - nums[i];
                if (map.has(complement) && map.get(complement) != i) {
                    return [i, map.get(complement)];
                }
            }
        }
   ```
   
   **复杂度分析**
    * 时间复杂度：O（N）
    * 空间复杂度：O（N）

3. 一遍哈希表

   仔细观察一下，我们可以发现，这个问题完全可以在向 `hashMap` 添加元素的时候就作出相应的判断，因此，我们将判断流程从第二次迭代中抽取出来，拿到第一遍迭代中，可以得到：
   
      ``` javascript
        // 使用了一次迭代
        var twoSum = function (nums, target) {
            const map = new Map();
            // 迭代过程中，判断需要的值是否在 hashMap 中
            // 存在的话对其进行输出，不存在的话将其设定在 hashMap 中
            for (let i = 0; i < nums.length; i++) {
                let complement = target - nums[i];
                if (map.has(complement)) {
                    return [map.get(complement), i];
                }
                map.set(nums[i], i);
            }
        }
   ```
   
**复杂度分析**
  * 时间复杂度：O（N）
  * 空间复杂度：O（N）

## 删除排序数组中的重复项

也是一道非常简单的题目，这里可以使用双指针法进行解题。

放置两个指针，其中 `i` 是慢指针，`j` 是快指针，只要 `nums[i] = nums[j]`，增加 `j` 以跳过重复项。

一旦 `nums[i] !== nums[j]`，代表跳过重复项运行已结束，因此需要把 `nums[j]` 的值复制到 `nums[i+1]`，然后递增 `i`，接着重复上述流程，直至 `j` 到达数组尾。
    
  ``` javascript
    var removeDuplicates = function (nums) {
        if (nums.length == 0) return 0;
        // 设定一个慢速指针
        let i = 0;
        for (let j = 1; j < nums.length; j++) {
            // 设定一个快速指针 j，将其作为遍历指针
            // 当快速指针指到非重复值时，将非重复值设定到慢速指针后，替换数组元素
            if (nums[j] != nums[i]) {
                i++;
                nums[i] = nums[j];
            }
        }
        // 最后输出慢速指针的值，即为整个数组的值
        return i + 1;
    }
   ```
   
**复杂度分析**
  * 时间复杂度：O（N）
  * 空间复杂度：O（1）


## 移除元素

这道题的解决方案也是主要依靠双指针进行的，和上一道题类似，设定一个快指针，一个慢指针

  ``` javascript
    var removeDuplicates = function (nums, val) {
        // 设定一个慢速指针
        let i = 0;
        for (let j = 1; j < nums.length; j++) {
            // 设定一个快速指针 j，将其作为遍历指针
            // 当快速指针指到目标值时，移动快速指针到目标值后，复制 nums[j] 到 nums[i]，同时递增快速指针和慢速指针，依次进行复制
            if (nums[j] != val) {
                nums[i] = nums[j];
                i++;
            }
        }
        // 最后输出慢速指针的值，即为整个数组长度
        return i;
    }
   ```

## 搜索插入位置

# medium

# hard


