---
layout: post
title: Dynamic Programming（动态规划小结）
date: 2019-12-30T08:06:22.718Z
author: Helve
tags:
  - LeetCode
image: /asset/2018-04-21.jpg
---
# Dynamic Programming（动态规划小结）

动态规划作为面试界的一项必考点，常年出现于各类培训课程中，充当课程压轴 / 高深算法代表，这让我一度以为动态规划是一项非常难以掌握的知识点，看一看 [动态规划](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92 "动态规划") 的维基百科介绍：

> 动态规划在寻找有很多重叠子问题的情况的最佳解时有效，它将问题重新组合成子问题。为了避免重复解决这些子问题，它们的结果都逐渐被计算并被储存，从简单的问题到整个问题被解决。因此，动态规划储存递归时的结果，因而不会在解决同样的问题时浪费时间。
> 
> 动态规划只能应用于有最佳子结构的问题，最佳子结构的意思是局部最佳解能决定全域最佳解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单的说，问题能够被分解成子问题来解决。

emmm……存储……组合……自己算自己？？？

![一脸懵逼](http://imagetemp.oss-cn-beijing.aliyuncs.com/blog/2019-12-30-074956.jpg "一脸懵逼")

然后刷 `leetcode` 的时候看了看斐波那契数列的 `dp` 解决方案……

![九脸懵逼](http://imagetemp.oss-cn-beijing.aliyuncs.com/blog/2019-12-30-075001.jpg "九脸懵逼")

这什么玩意……简单解法它不香吗？？？

这个问题困扰了我很长时间，期间一直在忙活业务代码的事情，然后突然有一天刷知乎看到了这篇文章 [如何理解动态规划](https://www.zhihu.com/question/39948290/answer/883302989 "如何理解动态规划")。

然后再看了看 `wikipedia` 上面的定义，然后突然间意识到这玩意好像名字取的有问题……

这个问题先按下不表，我们先来看一看动态规划能够解决的问题。

## 能用动态规划解决的问题

问题能否被解决，取决于它是否能推算出**状态转移方程**，简单一点来说就是一下几点：

1. 问题的答案依赖于问题的规模，即所有答案构成一个数列
2. 大规模问题的答案可以由小规模问题的答案递推得到，即  `f(n)`  可以由  `{f(i)|i<n}` 中的个别求得

借用一下知乎大神的案例：1 个人有 2 条腿，2 个人有 4 条腿……n 个人有多少条腿？答案当然是 `2n`，这里的 `2n` 时问题的答案，`n` 是问题的规模，显然问题的答案是依赖于问题的规模的，这里的例子构成间隔为 2 的等差数列。而这里可以得出 `f(n)=f(n-1)+2`。

## 适合用动态规划解决的问题

能够用动态规划解决的，不代表适合用，例如刚才的例子，可以直接写成  `f(n)=2n`  的显式表达式形式，斐波那契数列也是同理，但是有些场景下，`f(n)` 的显式例子是不容易的得到的，这时候就体现出动态规划的作用了。

## 应用动态规划，将整体问题拆分成三个子目标

1. 建立状态转移方程

	实际上这一步是最为复杂的一点，只需要抓住一个思维： **当作已经知道 `f(1) - f(n-1) 的值，然后利用它们求得 f(n)`**。上面的例子中，状态转移方程就是最后求出的 `f(n)=f(n-1) + 2`。

2. 缓存并复用以往结果

	实际上我们经常见到的自底向上、自顶向下、记忆化搜索都是为了完成这一步的操作，简单想一想也就能明白，上面的例子中，如果 `f(100)` 是从 `f(1)` 一路计算上来，而不是缓存的 `f(99)` 再做计算，这里的计算次数就是 `100`，但是如果缓存过，就可以利用状态转移方程一次计算得出结果。

3. 按照顺序从小往大算

	这里的 `小` 和 `大` 指的是问题的规模，在这里就是从 `f(1)` 到 `f(n)` 依次计算。上面的例子中是显而易见的，但是复杂问题中可能会乱套，所以必须记住这同样是目标之一。

## 和数列的关系

上面的方案都是摘抄自知乎文章，看了半天关系，让我想起来高中时讲过的数列题，同样的给出一串数字，让你求第 `n` 个是多少。

动态规划和高中数列题的唯一差别是，高中数列题可以运用状态转移方程（高中时一般凭直觉猜……）推导出通项公式，但是动态规划是利用状态转移方程直接运用计算机暴力求解。通项公式在动态规划中是不存在的（也就是高中时凭直觉蒙出答案 / 大量演算得出答案）。

就是因为要进行暴力计算，所以上面的三个子目标中有两个都涉及时间 / 空间复杂度优化：

* 缓存中间结果：搞个数组之类的变量记录中间结果，避免重复计算导致时间复杂度过高
* 按顺序从小往大算：搞个 `for` 循环依次计算

这个步骤和高中时草稿纸上演算，记录下一大堆已有结果，然后重复这个流程推出正确答案的过程有异曲同工之处。

## 实例

